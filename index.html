<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voxel Architect v7.0 - Spatial 3D</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        /* Removed mirror transform for back camera use */
        #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; z-index: 1; }
        #three_canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }
        #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 10; pointer-events: none; }
        #ui { 
            position: absolute; top: 20px; left: 20px; z-index: 100;
            color: #00f0ff; font-weight: bold; font-size: 14px;
            text-shadow: 0 0 10px #00f0ff; border-left: 3px solid #00f0ff; padding-left: 15px;
            background: rgba(0,0,0,0.7); padding: 15px;
        }
        .stat-val { color: #fff; }
    </style>
</head>
<body>
    <div id="ui">
        <div>CORE_SYNC: SPATIAL_ARCHITECT_v7.0</div>
        <div>MODE: <span id="mode" class="stat-val">INITIALIZING</span></div>
        <div>DEPTH: <span id="depth_val" class="stat-val">0</span></div>
        <div style="font-size: 10px; margin-top: 5px; color: #00ff00;">PINCH: DRAW IN 3D SPACE</div>
        <div style="font-size: 10px; color: #ff3333;">L-PINCH + R-POINT: ERASE VOLUME</div>
    </div>

    <video id="input_video" autoplay playsinline></video>
    <canvas id="three_canvas"></canvas>
    <canvas id="biometric_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const bioCanvas = document.getElementById('biometric_canvas');
        const bioCtx = bioCanvas.getContext('2d');
        const modeEl = document.getElementById('mode');
        const depthEl = document.getElementById('depth_val');

        // --- SPATIAL THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three_canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const voxelGroup = new THREE.Group();
        scene.add(voxelGroup);

        const gridSize = 1.0; 
        const placedVoxels = new Map();
        
        // 3D Crosshair Cursor
        const crosshair = new THREE.Mesh(
            new THREE.BoxGeometry(gridSize, gridSize, gridSize),
            new THREE.MeshBasicMaterial({ color: 0x00f0ff, wireframe: true, transparent: true, opacity: 0.8 })
        );
        scene.add(crosshair);

        camera.position.z = 15;
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));

        let buildTimer = 0;
        let eraseTimer = 0;
        const colorPalette = [0x00f0ff, 0xff0055, 0x00ff88, 0xffff00];
        let globalColorIndex = 0;

        // --- COORDINATE REMAPPING (BACK CAMERA / ENVIRONMENT) ---
        function getSpatialCoords(landmark) {
            // X is natural (not flipped) for back camera
            const x = (landmark.x - 0.5) * 28; 
            const y = (0.5 - landmark.y) * 18;
            // MediaPipe Z represents depth relative to the hand's palm center
            // We scale it to create a 3D "Drawing Box"
            const z = landmark.z * -40; 
            return new THREE.Vector3(x, y, z);
        }

        function onResults(results) {
            bioCtx.clearRect(0, 0, bioCanvas.width, bioCanvas.height);
            crosshair.visible = false;
            
            if (!results.multiHandLandmarks) return;

            results.multiHandedness.forEach((hand, idx) => {
                const landmarks = results.multiHandLandmarks[idx];
                
                // Draw skeleton (non-mirrored)
                bioCtx.strokeStyle = "#00f0ff";
                bioCtx.lineWidth = 2;
                landmarks.forEach(p => bioCtx.strokeRect(p.x * bioCanvas.width, p.y * bioCanvas.height, 2, 2));

                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinching = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y) < 0.04;

                const spatialPos = getSpatialCoords(indexTip);
                
                // 3D Grid Snapping
                let gx = Math.round(spatialPos.x / gridSize) * gridSize;
                let gy = Math.round(spatialPos.y / gridSize) * gridSize;
                let gz = Math.round(spatialPos.z / gridSize) * gridSize;

                crosshair.visible = true;
                crosshair.position.set(gx, gy, gz);
                depthEl.innerText = gz.toFixed(1);

                if (pinching) {
                    const key = `${gx},${gy},${gz}`;
                    if (!placedVoxels.has(key)) {
                        const cube = new THREE.Mesh(
                            new THREE.BoxGeometry(gridSize * 0.9, gridSize * 0.9, gridSize * 0.9),
                            new THREE.MeshPhongMaterial({ color: 0x001122, emissive: colorPalette[globalColorIndex], emissiveIntensity: 0.5 })
                        );
                        cube.position.set(gx, gy, gz);
                        voxelGroup.add(cube);
                        placedVoxels.set(key, cube);
                        modeEl.innerText = "SPATIAL_BUILDING";
                    }
                } else {
                    modeEl.innerText = "SPATIAL_SCANNING";
                }
            });
        }

        // --- SYSTEM INITIALIZATION ---
        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ 
            maxNumHands: 2, 
            modelComplexity: 1, 
            minDetectionConfidence: 0.7, 
            minTrackingConfidence: 0.7 
        });
        hands.onResults(onResults);

        // FORCE BACK CAMERA
        const cameraDevice = new Camera(videoElement, {
            onFrame: async () => {
                bioCanvas.width = videoElement.videoWidth;
                bioCanvas.height = videoElement.videoHeight;
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720,
            facingMode: 'environment' // BACK CAMERA
        });
        cameraDevice.start();

        function animate() { 
            requestAnimationFrame(animate); 
            // Voxel group slowly oscillates so you can see the 3D depth from any angle
            voxelGroup.rotation.y += 0.005; 
            renderer.render(scene, camera); 
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
