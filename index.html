<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voxel Architect v1.9.0 - Multi-Spectral Workspace</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; }
        #three_canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }
        #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 10; transform: scaleX(-1); pointer-events: none; }
        #ui { 
            position: absolute; top: 20px; left: 20px; z-index: 100;
            color: #00f0ff; font-weight: bold; font-size: 14px;
            text-shadow: 0 0 10px #00f0ff; border-left: 3px solid #00f0ff; padding-left: 15px;
            background: rgba(0,0,0,0.6); padding: 15px;
        }
        .stat-val { color: #fff; }
    </style>
</head>
<body>
    <div id="ui">
        <div>VOXEL_ARCHITECT_v1.9.0</div>
        <div>TOOL: <span id="active_mode" class="stat-val">INITIALIZING</span></div>
        <div>COLOR: <span id="active_color" class="stat-val">CYAN</span></div>
        <div>VOXELS: <span id="count" class="stat-val">0</span></div>
    </div>

    <video id="input_video" autoplay playsinline></video>
    <canvas id="three_canvas"></canvas>
    <canvas id="biometric_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const bioCanvas = document.getElementById('biometric_canvas');
        const bioCtx = bioCanvas.getContext('2d');
        const modeEl = document.getElementById('active_mode');
        const colorEl = document.getElementById('active_color');
        const countEl = document.getElementById('count');

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three_canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const voxelGroup = new THREE.Group();
        scene.add(voxelGroup);

        const palette = [0x00f0ff, 0xff3366, 0x00ff66, 0xffcc00, 0xff00ff];
        const colorNames = ["CYAN", "ROSE", "NEON", "GOLD", "VOID"];
        let colorIdx = 0;
        let gridSize = 1.2; 
        const placedVoxels = new Map();
        
        const ghostGeo = new THREE.BoxGeometry(1, 1, 1);
        const ghostMat = new THREE.MeshPhongMaterial({ color: palette[0], transparent: true, opacity: 0.5, emissive: palette[0], emissiveIntensity: 0.5 });
        const ghostVoxel = new THREE.Mesh(ghostGeo, ghostMat);
        scene.add(ghostVoxel);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        camera.position.z = 22;

        let toolMode = 1, menuOpen = false, paletteOpen = false;
        let menuPos = { x: 0, y: 0 }, palPos = { x: 0, y: 0 };
        let slideStartX = null, startVal = null;
        let menuTimer = 0, actionTimer = 0, palTimer = 0;
        
        const HOLD_DURATION = 180;
        const TRIGGER_DIST = 0.06;

        function getDist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }

        function drawProgress(ctx, x, y, progress, color) {
            if (progress <= 0 || progress >= 1) return; 
            ctx.beginPath(); ctx.arc(x, y, 32, -Math.PI/2, (-Math.PI/2) + (Math.PI * 2 * progress));
            ctx.lineWidth = 6; ctx.strokeStyle = color; ctx.stroke();
        }

        function drawMenus(ctx) {
            if (menuOpen) {
                const { x, y } = menuPos;
                ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(x - 130, y - 140, 260, 60);
                ["ADD", "PAINT", "SCL", "ROT"].forEach((l, i) => {
                    ctx.strokeStyle = (toolMode === i+1) ? "#00ff00" : "#555";
                    ctx.strokeRect(x - 120 + (i*65), y - 130, 60, 40);
                    ctx.fillStyle = "#fff"; ctx.fillText(l, x - 110 + (i*65), i === 1 ? y - 105 : y - 105);
                });
            }
            if (paletteOpen) {
                const { x, y } = palPos;
                palette.forEach((c, i) => {
                    ctx.fillStyle = `#${c.toString(16).padStart(6, '0')}`;
                    if(colorIdx === i) ctx.strokeStyle = "#fff", ctx.lineWidth = 4, ctx.strokeRect(x-60+(i*25), y-100, 20, 20);
                    ctx.fillRect(x - 60 + (i * 25), y - 100, 20, 20);
                });
            }
        }

        function onResults(results) {
            bioCtx.clearRect(0, 0, bioCanvas.width, bioCanvas.height);
            ghostVoxel.visible = false;
            if (!results.multiHandLandmarks) return;

            let rHand = results.multiHandLandmarks[results.multiHandedness.findIndex(h => h.label === 'Right')];
            if (rHand) {
                const thumb = rHand[4], index = rHand[8], mid = rHand[12], ring = rHand[16], pinky = rHand[20];
                const ringClosed = ring.y > rHand[14].y, pinkyClosed = pinky.y > rHand[18].y, midClosed = mid.y > rHand[10].y;

                const menuPinch = getDist(index, mid) < TRIGGER_DIST && ringClosed && pinkyClosed;
                const palettePinch = getDist(thumb, mid) < TRIGGER_DIST && ringClosed && pinkyClosed;
                const actionPinch = getDist(thumb, index) < TRIGGER_DIST && midClosed && ringClosed && pinkyClosed;
                
                const ix = index.x * bioCanvas.width, iy = index.y * bioCanvas.height;
                const mx = mid.x * bioCanvas.width, my = mid.y * bioCanvas.height;

                // Palette Toggle (Thumb + Mid)
                if (palettePinch) {
                    palTimer += 16;
                    if (palTimer < HOLD_DURATION) drawProgress(bioCtx, mx, my, palTimer/HOLD_DURATION, "#fff");
                    else { 
                        if(!paletteOpen) { paletteOpen = true; palPos = {x: mx, y: my}; }
                        colorIdx = (colorIdx + 1) % palette.length;
                        ghostMat.color.set(palette[colorIdx]); ghostMat.emissive.set(palette[colorIdx]);
                        palTimer = 1; 
                    }
                } else { palTimer = 0; if(!palettePinch) paletteOpen = false; }

                // Main Menu Toggle (Index + Mid)
                if (menuPinch) {
                    menuTimer += 16;
                    if (menuTimer < HOLD_DURATION) drawProgress(bioCtx, ix, iy, menuTimer/HOLD_DURATION, "#00f0ff");
                    else { menuOpen = !menuOpen; menuPos = { x: ix, y: iy }; menuTimer = -600; }
                } else if (menuTimer < 0) menuTimer += 16; else menuTimer = 0;

                drawMenus(bioCtx);

                if (!menuOpen) {
                    const worldPos = new THREE.Vector3((0.5 - index.x) * 28, (0.5 - index.y) * 20, 0); 
                    const localPos = voxelGroup.worldToLocal(worldPos.clone());
                    let gx = Math.round(localPos.x / gridSize), gy = Math.round(localPos.y / gridSize);
                    const key = `${gx},${gy},0`;

                    if (toolMode <= 2) {
                        ghostVoxel.visible = true;
                        ghostVoxel.position.copy(voxelGroup.localToWorld(new THREE.Vector3(gx * gridSize, gy * gridSize, 0)));
                        
                        if (actionPinch) {
                            actionTimer += 16;
                            if (actionTimer >= HOLD_DURATION) {
                                if (toolMode === 1 && !placedVoxels.has(key)) {
                                    const mesh = new THREE.Mesh(ghostGeo, new THREE.MeshPhongMaterial({ color: palette[colorIdx], emissive: palette[colorIdx], emissiveIntensity: 0.4 }));
                                    mesh.position.set(gx * gridSize, gy * gridSize, 0); mesh.scale.set(gridSize, gridSize, gridSize);
                                    mesh.origPos = { x: gx, y: gy };
                                    voxelGroup.add(mesh); placedVoxels.set(key, mesh);
                                } else if (toolMode === 2 && placedVoxels.has(key)) {
                                    const v = placedVoxels.get(key);
                                    v.material.color.set(palette[colorIdx]); v.material.emissive.set(palette[colorIdx]);
                                }
                                countEl.innerText = placedVoxels.size; actionTimer = 150;
                            }
                        } else actionTimer = 0;
                    } else if (actionPinch) { // SCL/ROT logic
                        if (slideStartX === null) { slideStartX = thumb.x; startVal = (toolMode === 3) ? gridSize : voxelGroup.rotation.y; }
                        if (toolMode === 3) {
                            gridSize = Math.max(0.4, Math.min(4.0, startVal - (thumb.x - slideStartX) * 8));
                            voxelGroup.children.forEach(c => { c.position.set(c.origPos.x * gridSize, c.origPos.y * gridSize, 0); c.scale.set(gridSize, gridSize, gridSize); });
                        } else {
                            let newRot = startVal - (thumb.x - slideStartX) * 6;
                            const snap = Math.round(newRot / (Math.PI / 2)) * (Math.PI / 2);
                            voxelGroup.rotation.y = Math.abs(newRot - snap) < 0.15 ? snap : newRot;
                        }
                    } else slideStartX = null;
                } else if (actionPinch) { // Cycle tools while menu open
                    actionTimer += 16;
                    if (actionTimer >= HOLD_DURATION) { toolMode = (toolMode % 4) + 1; actionTimer = 1; }
                } else actionTimer = 0;

                modeEl.innerText = ["", "ADD", "PAINT", "SCALE", "ROTATE"][toolMode];
                colorEl.innerText = colorNames[colorIdx];
            }
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
        hands.onResults(onResults);
        new Camera(videoElement, { onFrame: async () => { 
            bioCanvas.width = videoElement.videoWidth; bioCanvas.height = videoElement.videoHeight; await hands.send({image: videoElement}); 
        }, width: 1280, height: 720 }).start();

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
