<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voxel Architect v2.2.0 - Word Stamp</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: 1; }
        #three_canvas { position: absolute; top: 0; left: 0; z-index: 5; pointer-events: none; }
        #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 10; transform: scaleX(-1); pointer-events: none; }
        #ui { 
            position: absolute; top: 20px; left: 20px; z-index: 100;
            color: #00f0ff; font-weight: bold; font-size: 14px;
            text-shadow: 0 0 10px #00f0ff; border-left: 3px solid #00f0ff; padding-left: 15px;
            background: rgba(0,0,0,0.6); padding: 15px;
        }
        #text_input {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 200; background: rgba(0,0,0,0.9); border: 2px solid #00f0ff;
            color: #00f0ff; padding: 20px; font-size: 24px; outline: none; display: none;
        }
        .stat-val { color: #fff; }
    </style>
</head>
<body>
    <div id="ui">
        <div>VOXEL_ARCHITECT_v2.2.0</div>
        <div>TOOL: <span id="active_mode" class="stat-val">INIT</span></div>
        <div>COLOR: <span id="active_color" class="stat-val">CYAN</span></div>
        <div>VOXELS: <span id="count" class="stat-val">0</span></div>
    </div>
    <input type="text" id="text_input" placeholder="TYPE WORD + ENTER">

    <video id="input_video" autoplay playsinline></video>
    <canvas id="three_canvas"></canvas>
    <canvas id="biometric_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('input_video');
        const bioCanvas = document.getElementById('biometric_canvas');
        const bioCtx = bioCanvas.getContext('2d');
        const textInput = document.getElementById('text_input');
        const modeEl = document.getElementById('active_mode');
        const colorEl = document.getElementById('active_color');
        const countEl = document.getElementById('count');

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three_canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const voxelGroup = new THREE.Group();
        scene.add(voxelGroup);

        const palette = [0x00f0ff, 0xff3366, 0x00ff66, 0xffcc00, 0xff00ff];
        const colorNames = ["CYAN", "ROSE", "NEON", "GOLD", "VOID"];
        let colorIdx = 0, gridSize = 1.2, toolMode = 1;
        let menuOpen = false, paletteOpen = false, isTyping = false;
        let menuPos = {x:0, y:0}, palPos = {x:0, y:0};
        let menuTimer = 0, actionTimer = 0, palTimer = 0, paintPriorityTimer = 0;
        const placedVoxels = new Map();
        
        const ghostVoxel = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshPhongMaterial({ transparent:true, opacity:0.5, emissiveIntensity:0.4 }));
        scene.add(ghostVoxel);
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        camera.position.z = 25;

        const HOLD_DURATION = 150, TRIGGER_DIST = 0.072, PROXIMITY_LIMIT = 0.065;

        function getDist(p1, p2) { return Math.sqrt(Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2)); }

        function createVoxel(gx, gy, gz, color) {
            const geo = new THREE.BoxGeometry(0.96, 0.96, 0.96);
            const mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: 0x0a0a0a, emissive: color, emissiveIntensity: 0.5 }));
            mesh.origPos = { x: gx, y: gy, z: gz };
            mesh.position.set(gx * gridSize, gy * gridSize, gz * gridSize);
            mesh.scale.set(gridSize, gridSize, gridSize);
            mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: color })));
            return mesh;
        }

        // Logic to draw text using the createVoxel function
        function stampText(text, startX, startY) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = "8px monospace";
            const width = Math.ceil(ctx.measureText(text).width);
            canvas.width = width; canvas.height = 10;
            ctx.font = "8px monospace"; ctx.fillStyle = "white";
            ctx.fillText(text, 0, 8);
            const imgData = ctx.getImageData(0,0,width,10).data;

            for(let y=0; y<10; y++) {
                for(let x=0; x<width; x++) {
                    if(imgData[(y*width+x)*4 + 3] > 128) {
                        let gx = startX + x, gy = startY - y;
                        let key = `${gx},${gy},0`;
                        if(!placedVoxels.has(key)) {
                            const v = createVoxel(gx, gy, 0, palette[colorIdx]);
                            voxelGroup.add(v); placedVoxels.set(key, v);
                        }
                    }
                }
            }
            countEl.innerText = placedVoxels.size;
        }

        textInput.addEventListener('keydown', (e) => {
            if(e.key === 'Enter') {
                const worldPos = ghostVoxel.position.clone();
                const localPos = voxelGroup.worldToLocal(worldPos);
                stampText(textInput.value, Math.round(localPos.x/gridSize), Math.round(localPos.y/gridSize));
                textInput.style.display = 'none'; textInput.value = ''; isTyping = false;
            }
        });

        function onResults(results) {
            bioCtx.clearRect(0,0,bioCanvas.width, bioCanvas.height);
            ghostVoxel.visible = false;
            if(!results.multiHandLandmarks || isTyping) return;

            let rHand = results.multiHandLandmarks[results.multiHandedness.findIndex(h => h.label === 'Right')];
            if(rHand) {
                const thumb=rHand[4], index=rHand[8], mid=rHand[12], ring=rHand[16], pinky=rHand[20];
                const isIsolated = (p1, p2, others) => getDist(p1,p2) < TRIGGER_DIST && others.every(o => getDist(p1,o) > PROXIMITY_LIMIT);
                
                const menuPinch = isIsolated(index, mid, [thumb, ring, pinky]);
                const actionPinch = isIsolated(thumb, index, [mid, ring, pinky]);
                const palPinch = isIsolated(thumb, mid, [index, ring, pinky]);
                const mx = ((thumb.x+index.x)/2)*bioCanvas.width, my = ((thumb.y+index.y)/2)*bioCanvas.height;

                if(palPinch && !menuOpen) {
                    palTimer += 16;
                    if(palTimer >= HOLD_DURATION) { paletteOpen = !paletteOpen; palPos = {x:mx, y:my}; palTimer = -500; if(!paletteOpen) paintPriorityTimer = 2000; }
                } else palTimer = Math.max(-500, palTimer - 16);

                if(paletteOpen) {
                    bioCtx.fillStyle = "rgba(0,0,0,0.8)"; bioCtx.fillRect(palPos.x-75, palPos.y-120, 150, 45);
                    palette.forEach((c,i) => {
                        bioCtx.fillStyle = `#${c.toString(16).padStart(6,'0')}`;
                        if(colorIdx === i) { bioCtx.strokeStyle="#fff"; bioCtx.strokeRect(palPos.x-65+(i*28), palPos.y-110, 22, 22); }
                        bioCtx.fillRect(palPos.x-65+(i*28), palPos.y-110, 22, 22);
                    });
                    if(actionPinch) { actionTimer += 16; if(actionTimer >= HOLD_DURATION) { colorIdx = (colorIdx+1)%palette.length; actionTimer = 1; }} else actionTimer = 0;
                } else {
                    if(menuPinch) {
                        menuTimer += 16;
                        if(menuTimer >= HOLD_DURATION) { menuOpen = !menuOpen; menuPos = {x:mx, y:my}; menuTimer = -500; }
                    } else menuTimer = Math.max(-500, menuTimer - 16);

                    if(menuOpen) {
                        bioCtx.fillStyle = "rgba(0,0,0,0.8)"; bioCtx.fillRect(menuPos.x-130, menuPos.y-140, 320, 80);
                        [{id:1,l:"ADD"},{id:2,l:"D/P"},{id:3,l:"SCL"},{id:4,l:"ROT"},{id:5,l:"TXT"}].forEach((m,i) => {
                            bioCtx.strokeStyle = (toolMode === m.id) ? "#00f0ff" : "#444";
                            bioCtx.strokeRect(menuPos.x-120+(i*62), menuPos.y-110, 50, 40);
                            bioCtx.fillStyle = "#fff"; bioCtx.fillText(m.l, menuPos.x-115+(i*62), menuPos.y-85);
                        });
                        if(actionPinch) { actionTimer += 16; if(actionTimer >= HOLD_DURATION) { toolMode = (toolMode % 5)+1; actionTimer = 1; }} else actionTimer = 0;
                    } else {
                        const worldPos = new THREE.Vector3((0.5 - (thumb.x+index.x)/2)*28, (0.5 - (thumb.y+index.y)/2)*20, 0);
                        const localPos = voxelGroup.worldToLocal(worldPos.clone());
                        let gx = Math.round(localPos.x/gridSize), gy = Math.round(localPos.y/gridSize);
                        
                        ghostVoxel.visible = (toolMode <= 2 || toolMode === 5);
                        ghostVoxel.position.copy(voxelGroup.localToWorld(new THREE.Vector3(gx*gridSize, gy*gridSize, 0)));
                        ghostVoxel.material.emissive.set(palette[colorIdx]);

                        if(actionPinch) {
                            if(toolMode === 5) { textInput.style.display = 'block'; textInput.focus(); isTyping = true; }
                            else {
                                actionTimer += 16;
                                if(actionTimer >= HOLD_DURATION) {
                                    const key = `${gx},${gy},0`;
                                    if(toolMode === 1 && !placedVoxels.has(key)) {
                                        const v = createVoxel(gx, gy, 0, palette[colorIdx]); voxelGroup.add(v); placedVoxels.set(key, v);
                                    } else if(toolMode === 2 && placedVoxels.has(key)) {
                                        if(paintPriorityTimer > 0) {
                                            const v = placedVoxels.get(key); v.material.emissive.set(palette[colorIdx]); v.children[0].material.color.set(palette[colorIdx]);
                                        } else { voxelGroup.remove(placedVoxels.get(key)); placedVoxels.delete(key); }
                                    }
                                    actionTimer = 150;
                                }
                            }
                        } else actionTimer = 0;
                        if(paintPriorityTimer > 0) paintPriorityTimer -= 16;
                    }
                }
                modeEl.innerText = ["","ADD",paintPriorityTimer > 0 ? "PAINT":"DEL","SCL","ROT","TXT"][toolMode];
                colorEl.innerText = colorNames[colorIdx]; colorEl.style.color = `#${palette[colorIdx].toString(16)}`;
            }
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
        hands.onResults(onResults);
        new Camera(videoElement, { onFrame: async () => { 
            bioCanvas.width = videoElement.videoWidth; bioCanvas.height = videoElement.videoHeight; await hands.send({image: videoElement}); 
        }, width: 1280, height: 720 }).start();

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
