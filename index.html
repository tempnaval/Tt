// --- NEW VARIABLES ADDED TO YOUR CORE ---
const palette = [0x00f0ff, 0xff3366, 0x00ff66, 0xffcc00, 0xff00ff];
const colorNames = ["CYAN", "ROSE", "NEON", "GOLD", "VOID"];
let colorIdx = 0;
let paletteOpen = false;
let palPos = { x: 0, y: 0 };
let palTimer = 0;
const PROXIMITY_LIMIT = 0.065;

// --- MERGED LOGIC WITHIN onResults ---
function onResults(results) {
    bioCtx.clearRect(0, 0, bioCanvas.width, bioCanvas.height);
    ghostVoxel.visible = false;
    if (!results.multiHandLandmarks) return;

    let rHand = null;
    results.multiHandedness.forEach((hand, idx) => {
        if(hand.label === 'Right') rHand = results.multiHandLandmarks[idx];
    });

    if (rHand) {
        const thumb = rHand[4], index = rHand[8], mid = rHand[12], ring = rHand[16], pinky = rHand[20];
        
        // NEW: Isolated Proximity Check
        const isIsolated = (p1, p2, others) => {
            if (getDist(p1, p2) > TRIGGER_DIST) return false;
            return others.every(o => getDist(p1, o) > PROXIMITY_LIMIT && getDist(p2, o) > PROXIMITY_LIMIT);
        };

        const menuPinch = isIsolated(index, mid, [thumb, ring, pinky]);
        const palettePinch = isIsolated(thumb, mid, [index, ring, pinky]);
        const actionPinch = isIsolated(thumb, index, [mid, ring, pinky]);
        
        const ix = index.x * bioCanvas.width, iy = index.y * bioCanvas.height;
        const mx = mid.x * bioCanvas.width, my = mid.y * bioCanvas.height;
        const tx = thumb.x * bioCanvas.width, ty = thumb.y * bioCanvas.height;

        // 1. PALETTE PRIORITY (New Functionality)
        if (palettePinch && !menuOpen) {
            palTimer += 16;
            if (palTimer < HOLD_DURATION) drawProgress(bioCtx, mx, my, palTimer/HOLD_DURATION, "#fff");
            else { paletteOpen = !paletteOpen; palPos = {x: mx, y: my}; palTimer = -600; }
        } else if (palTimer < 0) palTimer += 16; else palTimer = 0;

        if (paletteOpen) {
            drawPaletteUI(bioCtx, palPos);
            if (actionPinch) { // Cycle colors while palette is open
                actionTimer += 16;
                drawProgress(bioCtx, tx, ty, (actionTimer % HOLD_DURATION)/HOLD_DURATION, "#fff");
                if (actionTimer >= HOLD_DURATION) { 
                    colorIdx = (colorIdx + 1) % palette.length; 
                    ghostMat.color.set(palette[colorIdx]);
                    actionTimer = 1; 
                }
            } else actionTimer = 0;
            return; // Block other functions when palette is open
        }

        // 2. EXISTING MENU LOGIC (Enhanced with actionPinch Priority)
        if (menuPinch) {
            menuTimer += 16; drawProgress(bioCtx, ix, iy, Math.min(menuTimer/HOLD_DURATION, 1), "#00f0ff");
            if (menuTimer >= HOLD_DURATION) { menuOpen = !menuOpen; if (menuOpen) menuPos = { x: ix, y: iy }; menuTimer = -500; }
        } else if (menuTimer < 0) menuTimer += 16; else menuTimer = 0;

        if (menuOpen) {
            drawFixedMenu(bioCtx);
            if (actionPinch) {
                actionTimer += 16;
                drawProgress(bioCtx, tx, ty, Math.min(actionTimer/HOLD_DURATION, 1), "#00ff00");
                if (actionTimer >= HOLD_DURATION) { toolMode = (toolMode % 4) + 1; actionTimer = -500; }
            } else actionTimer = 0;
        } else {
            // 3. WORKSPACE LOGIC (Integrated Paint & Add Priority)
            const worldPos = new THREE.Vector3((0.5 - index.x) * 28, (0.5 - index.y) * 20, 0);
            const localPos = voxelGroup.worldToLocal(worldPos.clone());
            let gx = Math.round(localPos.x / gridSize), gy = Math.round(localPos.y / gridSize);
            const key = `${gx},${gy},0`;

            if (toolMode <= 2) {
                ghostVoxel.visible = true;
                ghostVoxel.position.copy(voxelGroup.localToWorld(new THREE.Vector3(gx * gridSize, gy * gridSize, 0)));
                ghostVoxel.material.color.set(palette[colorIdx]);

                if (actionPinch) {
                    actionTimer += 16;
                    if (actionTimer >= HOLD_DURATION) {
                        if (toolMode === 1 && !placedVoxels.has(key)) {
                            // ADD Logic
                            const v = createVoxel(gx, gy, palette[colorIdx]); 
                            voxelGroup.add(v); placedVoxels.set(key, v);
                        } else if (toolMode === 2 && placedVoxels.has(key)) {
                            // PAINT Logic (Replaces DEL when prioritizing color)
                            const v = placedVoxels.get(key);
                            v.material.emissive.set(palette[colorIdx]);
                            v.children[0].material.color.set(palette[colorIdx]);
                        }
                        countEl.innerText = placedVoxels.size; actionTimer = 150;
                    }
                } else actionTimer = 0;
            }
            // (Scale/Rotate functions remain unchanged from your v1.6.1)
        }
    }
}

// Support function for Palette UI
function drawPaletteUI(ctx, pos) {
    ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(pos.x - 70, pos.y - 120, 140, 40);
    palette.forEach((c, i) => {
        ctx.fillStyle = `#${c.toString(16).padStart(6, '0')}`;
        if(colorIdx === i) { ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.strokeRect(pos.x-60+(i*25), pos.y-110, 20, 20); }
        ctx.fillRect(pos.x - 60 + (i * 25), pos.y - 110, 20, 20);
    });
}
